!(function (e) {
  function t(i) {
    if (n[i]) return n[i].exports;
    var r = (n[i] = { exports: {}, id: i, loaded: !1 });
    return e[i].call(r.exports, r, r.exports, t), (r.loaded = !0), r.exports;
  }
  var n = {};
  return (t.m = e), (t.c = n), (t.p = ''), t(0);
})([
  function (e, t) {
    var n = AFRAME.utils.bind;
    if ('undefined' == typeof AFRAME)
      throw new Error(
        'Component attempted to register before AFRAME was available.',
      );
    var i = {
        CLICK: 'click',
        MOUSEENTER: 'mouseenter',
        MOUSEDOWN: 'mousedown',
        MOUSELEAVE: 'mouseleave',
        MOUSEUP: 'mouseup',
      },
      r = { HOVERING: 'cursor-hovering', HOVERED: 'cursor-hovered' };
    AFRAME.registerComponent('controller-cursor', {
      dependencies: ['raycaster'],
      schema: {
        color: { default: '#74BEC1' },
        downEvents: { default: ['triggerdown'] },
        radius: { default: 0.001 },
        upEvents: { default: ['triggerup'] },
      },
      init: function () {
        var e = this.el,
          t = this.data;
        (this.triggerDownEl = null),
          (this.intersection = null),
          (this.intersectedEl = null);
        var i = e.sceneEl.canvas;
        if (!i)
          return void e.sceneEl.addEventListener(
            'render-target-loaded',
            n(this.init, this),
          );
        e.setAttribute('raycaster', { near: 0.03 });
        var r = e.getAttribute('raycaster').far,
          s = r === 1 / 0 ? 1e3 : r,
          o = new THREE.CylinderBufferGeometry(t.radius, t.radius, s, 32),
          a = new THREE.MeshBasicMaterial({ color: t.color }),
          c = new THREE.Mesh(o, a);
        (c.position.z = (-1 * s) / 2),
          (c.rotation.x = 90 * (Math.PI / 180)),
          e.setObject3D('cursormesh', c),
          (this.onIntersectionBind = n(this.onIntersection, this)),
          (this.onIntersectionClearedBind = n(
            this.onIntersectionCleared,
            this,
          )),
          (this.onTriggerDownBind = n(this.onTriggerDown, this)),
          (this.onTriggerUpBind = n(this.onTriggerUp, this));
      },
      play: function () {
        var e = this.el,
          t = this.data,
          n = this;
        e.addEventListener('raycaster-intersection', this.onIntersectionBind),
          e.addEventListener(
            'raycaster-intersection-cleared',
            this.onIntersectionClearedBind,
          ),
          t.downEvents.forEach(function (t) {
            e.addEventListener(t, n.onTriggerDownBind);
          }),
          t.upEvents.forEach(function (t) {
            e.addEventListener(t, n.onTriggerUpBind);
          });
      },
      pause: function () {
        var e = this.el,
          t = this.data,
          n = this;
        e.removeEventListener(
          'raycaster-intersection',
          this.onIntersectionBind,
        ),
          e.removeEventListener(
            'raycaster-intersection-cleared',
            this.onIntersectionClearedBind,
          ),
          t.downEvents.forEach(function (t) {
            e.removeEventListener(t, n.onTriggerDownBind);
          }),
          t.upEvents.forEach(function (t) {
            e.removeEventListener(t, n.onTriggerUpBind);
          });
      },
      remove: function () {
        var e = this.el;
        e.removeObject3D('cursormesh');
      },
      onTriggerDown: function (e) {
        this.twoWayEmit(i.MOUSEDOWN), (this.triggerDownEl = this.intersectedEl);
      },
      onTriggerUp: function (e) {
        this.twoWayEmit(i.MOUSEUP),
          this.intersectedEl &&
            this.triggerDownEl === this.intersectedEl &&
            this.twoWayEmit(i.CLICK);
      },
      onIntersection: function (e) {
        var t,
          n,
          s,
          o = this,
          a = this.el;
        if (
          ((t = e.detail.els[0] === a ? 1 : 0),
          (s = e.detail.intersections[t]),
          (n = e.detail.els[t]))
        ) {
          if (this.intersectedEl === n) return void (this.intersection = s);
          this.intersectedEl && this.clearCurrentIntersection(),
            (this.intersection = s),
            (this.intersectedEl = n),
            a.addState(r.HOVERING),
            n.addState(r.HOVERED),
            o.twoWayEmit(i.MOUSEENTER);
        }
      },
      onIntersectionCleared: function (e) {
        var t = this.el,
          n = e.detail.el;
        t !== n && n === this.intersectedEl && this.clearCurrentIntersection();
      },
      clearCurrentIntersection: function () {
        var e = this.el;
        this.intersectedEl.removeState(r.HOVERED),
          e.removeState(r.HOVERING),
          this.twoWayEmit(i.MOUSELEAVE),
          (this.intersection = null),
          (this.intersectedEl = null);
      },
      twoWayEmit: function (e) {
        var t = this.el,
          n = this.intersectedEl,
          i = this.intersection;
        t.emit(e, { intersectedEl: n, intersection: i }),
          n && n.emit(e, { cursorEl: t, intersection: i });
      },
    });
  },
]);
